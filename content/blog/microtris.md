Title: Microtris
Preview: TEMP
Date: 2029-07-10
Tags: arduino

## Meet the Shield

<picture>
    <source srcset="/assets/microtris/hello-world.webp" type="image/webp">
    <source srcset="/assets/microtris/hello-world.jpg" type="image/jpg">
    <img src="/assets/microtris/hello-world.jpg" alt="&quot;Hello, World!&quot; followed by a smiley face, as displayed on a LCD text screen." loading="lazy">
</picture>

At first glance, the [1602 LCD Keypad Shield For Arduino](https://www.dfrobot.com/product-51.html)
seems like a powerful screen.

16 characters wide, 2 characters tall. 6 input buttons. 1 contrast control.

From $3 to $9, depending on where you get it, this display can stand out as an easy way to make simple games on an Arduino.

Or rather, it would, if it weren't for one major limitation:

<div class="indent">These displays only have 8 custom characters.</div>

And this is a common limitation among LCD text displays.

<picture>
    <source srcset="/assets/microtris/comparison1.webp" type="image/webp">
    <source srcset="/assets/microtris/comparison1.jpg" type="image/jpg">
    <img src="/assets/microtris/comparison1.jpg" alt="Three LCD text displays, arranged haphazardly" loading="lazy">
</picture>

## Gaming on a Text Display

Hello World:

```cpp
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

byte customChar[8] = {
  0b00000,
  0b01010,
  0b01010,
  0b00000,
  0b10001,
  0b01110,
  0b00000,
  0b00000
};

void setup() {
  lcd.createChar(0, customChar);
  lcd.begin(16, 2);  // start the library
  lcd.setCursor(0, 0);
  lcd.print("Hello, World!");  // print a simple message
  lcd.setCursor(0, 1);
  lcd.write((uint8_t)0);
}

void loop() {}
```

you can update custom characters live:

```cpp
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

// generated by https://omerk.github.io/lcdchargen/
byte customSmile[8] = {
  0b00000,
  0b01010,
  0b01010,
  0b00000,
  0b10001,
  0b01110,
  0b00000,
  0b00000
};

byte customFrown[8] = {
	0b00000,
	0b01010,
	0b01010,
	0b00000,
	0b00000,
	0b01110,
	0b10001,
	0b00000
};

void writeSmiley() {
  lcd.createChar(0, customSmile);
  lcd.setCursor(5, 0);
  lcd.write((uint8_t)0);
}

void writeFrown() {
  lcd.createChar(0, customFrown);
  lcd.setCursor(5, 0);
  lcd.write((uint8_t)0);
}

void setup() {
  lcd.begin(16, 2);  // start the library
}

bool happy = true;
void loop() {
  if (happy) {
    writeSmiley();
  } else {
    writeFrown();
  }
  happy = !happy;
  delay(1500);
}

```

## Write Full Block

```cpp
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

// write full block
void setup() {
  lcd.begin(16, 2);
  lcd.setCursor(0, 0);
  lcd.write((uint8_t)0b11111111);
}

void loop() {}

```

https://arduino.stackexchange.com/a/46833

### Approximate with other characters

```cpp
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

void setup() {
  lcd.begin(16, 2);
  lcd.setCursor(0, 0);

  uint8_t approximations[] = {
    161,  // bottom left dot
    223,  // top right dot
    95,   // bar bottom
    91,   // bar left
    93,   // bar right
    204   // bar top and bar right
  };

  for (auto a : approximations)
    lcd.write(a);

  lcd.setCursor(0, 1);
  lcd.write(255);
}

void loop() {}
```

Switching to Rust: https://blog.logrocket.com/complete-guide-running-rust-arduino/#rust-embedded-systems

Using this library: https://github.com/mjhouse/ag-lcd

I've decided to just use a 4x2 of characters, using all 8 characters at max resolution.

I want to have a general translation from `draw(x,y)` to applying to a specific character.

I want to keep the process of drawing to the screen relatively efficient, in terms of just copying everything 1:1.

I could have one 2d buffer which would then be chunked, but that seems like it would create unnecessary copies every time we write to the screen.
In this instance, I'd prefer more complex logic for fewer copies.

I need to:

1. Find which character needs to change.
2. Find which pixel in that character needs to change.

one character is a `byte[8]`, so having eight characters gives me an array of characters: `byte charBuffer[8][8]`.

One pixel is one bit in a character, so effectively I have to find a position in a 3d array.

| **x** | **y** | **index**                     |
| :---: | :---: | ----------------------------- |
|   0   |   0   | `charBuffer[0][0] = 0b10000;` |
|   1   |   0   | `charBuffer[0][0] = 0b01000;` |
|   0   |   1   | `charBuffer[0][1] = 0b10000;` |
|   2   |   2   | `charBuffer[0][2] = 0b00100;` |
|  10   |  10   | `charBuffer[5][1] = 0b00001;` |
|  20   |  16   | `charBuffer[7][7] = 0b00001;` |

used bitwise operators:

```cpp
byte getPattern(uint8_t x) {
  switch (x % character.pixelsWide) {
	case 0:
	  return 0b10000;
	case 1:
	  return 0b01000;
	case 2:
	  return 0b00100;
	case 3:
	  return 0b00010;
	case 4:
	  return 0b00001;
	default:
	  return 0;
  }
}
```

is the same as

```cpp
byte getPattern(uint8_t x) {
  return getPattern(x, 0b10000);
}

byte getPattern(uint8_t x, uint8_t initialState) {
  return initialState >> x % character.pixelsWide;
}
```

which is much more flexible.

### Blinking Face Example:

```cpp

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);
Display display = Display();

const uint8_t offset = 6;
void setup() {
  Serial.begin(9600);  // open the serial port at 9600 bps:
  lcd.begin(16, 2);

  // design stored as bits
  bool myDesign[8][7] = {
    { 0, 0, 0, 0, 0, 0, 0 },
    { 0, 1, 0, 0, 0, 1, 0 },
    { 0, 1, 0, 0, 0, 1, 0 },
    { 0, 0, 0, 0, 0, 0, 0 },
    { 1, 0, 0, 0, 0, 0, 1 },
    { 0, 1, 0, 0, 0, 1, 0 },
    { 0, 0, 1, 1, 1, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0 },
  };

  for (int y = 0; y < 8; y++)
    for (int x = 0; x < 7; x++)
      if (myDesign[y][x])
        display.draw(x + offset, y);

  display.printToLcd(lcd);
}

void loop() {
  // design stored as coords
  uint8_t coords[4][2] = {
    { 1, 1 },
    { 1, 2 },
    { 5, 1 },
    { 5, 2 },
  };
  for (auto [x, y] : coords)
    display.toggle(x + offset, y);

  display.printToLcd(lcd);
  delay(1000);
}
```

other rotate implementation:

https://code.rocketnine.space/tslocum/netris/src/commit/417d9a6ce7ba31a5e56bf10d06fffb9b1a5e85dd/pkg/mino/piece.go#L120-L172
